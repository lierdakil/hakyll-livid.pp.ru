---
author: Livid
date: 2009-10-05 06:15:52+00:00
title: Кросс-DistCC в Gentoo
wordpress_id: 361
tags: Compilation, Distcc, Gentoo ,Cheats, Gentoo, Soft
...

Недавно я [рассказывал](/?p=340) о том, как настроить distcc для ваших
машин с одинаковыми архитектурами.
Теперь я вкратце расскажу, что делать, если архитектуры разные.

<!--more-->


На самом деле, все довольно просто. Чтобы настроить кросс-тулчейн, в
комплект стандартной поставки Gentoo входит замечательная утилита
crossdev. Устанавливается она из портеджей. Чтобы посмотреть, какие
архитектуры она умеет, нужно сделать

    crossdev -t help

.
Чтобы собрать кросс-тулчейн, нужно выполнить

    crossdev -t arch

где arch -- требуемая архитектура, например, x86\_64.
Следует, однако, заметить, что для правильной работы crossdev нужен
настроенный локальный оверлей и его путь должен быть **первым** в списке
оверлеев. Таким образом, если вы используете layman, make.conf должен
выглядеть примерно следующим образом:

```bash
#Here we setup PORTDIR_OVERLAY so that first one is /usr/local/portage
PORTDIR_OVERLAY=""
source /usr/local/portage/layman/make.conf
PORTDIR_OVERLAY="/usr/local/portage
${PORTDIR_OVERLAY}"
```


Итак, после установки кросс-компилятора, distcc должен сам его понять и
утилизировать. Однако, вскоре вы заметите, что некоторые ебилды ставятся
нормально, в то время как другие выпадают с ошибками компиляции.
Это происходит потому, что нередко ебилды используют не полное название
компилятора (например, i686-pc-linux-gnu-gcc), а сокращенное (gcc).
distcc вызывает соответственно gcc удаленной машины и обламывается,
получив на 64-битной архитектуре 32-битный объектный файл. Чтобы этого
избежать, достаточно сделать на distcc-клиенте следующее:
1. Создать скрипт /usr/lib/distcc/bin/\${CHOST}-wrapper, где
\${CHOST} -- это CHOST из make.conf, следующего содержания:

    #!/bin/bash
    exec /usr/lib/distcc/bin/${CHOST}-g${0:$[-2]} "$@"

и сделать его исполняемым.
2. Сделать так, чтобы симлинки в /usr/lib/distcc/bin указывали на этот
скрипт:

```bash
cd /usr/lib/distcc/bin
rm cc c++ g++ gcc
echo cc c++ g++ gcc | xargs -n1 ln -s ${CHOST}-wrapper
```

, не забыв заменить \${CHOST} на его значение (или сделать source
/etc/make.conf).

После этого distcc будет работать с кросс-компилятором.

Еще одно замечание: при сборке x86 на x86\_64-процессорах, можно вместо
честного кросс-компилятора выполнять x86\_64-pc-linux-gnu-\* с
параметром -m32, однако этот метод, вообще говоря, неподдерживаемый и я
не гарантирую его работоспособность. Используйте на свой страх и риск.

Ссылки по теме:
[Gentoo Linux Documentation - DistCC cross-compiling
guide](http://www.gentoo.org/doc/en/cross-compiling-distcc.xml)
